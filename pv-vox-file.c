/*
 * Copyright (C) 2018 Robert Ancell
 *
 * This program is free software: you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later
 * version. See http://www.gnu.org/copyleft/gpl.html the full text of the
 * license.
 */

#include <ctype.h>

#include "pv-vox-file.h"

struct _PvVoxFile
{
    GObject       parent_instance;

    GFile        *file;

    guint8       *data;
    gsize         data_length;

    GPtrArray    *models;

    PvVoxMaterial materials[256];
};

typedef struct
{
    guint32 size_x;
    guint32 size_y;
    guint32 size_z;
    guint8 *voxels;
    guint32 voxels_length;
} VoxModel;

G_DEFINE_TYPE (PvVoxFile, pv_vox_file, G_TYPE_OBJECT)

static guint8 default_palette[1024] =
{
    0x00, 0x00, 0x00, 0x00,  0xff, 0xff, 0xff, 0xff,  0xff, 0xff, 0xcc, 0xff,  0xff, 0xff, 0x99, 0xff,
    0xff, 0xff, 0x66, 0xff,  0xff, 0xff, 0x33, 0xff,  0xff, 0xff, 0x00, 0xff,  0xff, 0xcc, 0xff, 0xff,
    0xff, 0xcc, 0xcc, 0xff,  0xff, 0xcc, 0x99, 0xff,  0xff, 0xcc, 0x66, 0xff,  0xff, 0xcc, 0x33, 0xff,
    0xff, 0xcc, 0x00, 0xff,  0xff, 0x99, 0xff, 0xff,  0xff, 0x99, 0xcc, 0xff,  0xff, 0x99, 0x99, 0xff,
    0xff, 0x99, 0x66, 0xff,  0xff, 0x99, 0x33, 0xff,  0xff, 0x99, 0x00, 0xff,  0xff, 0x66, 0xff, 0xff,
    0xff, 0x66, 0xcc, 0xff,  0xff, 0x66, 0x99, 0xff,  0xff, 0x66, 0x66, 0xff,  0xff, 0x66, 0x33, 0xff,
    0xff, 0x66, 0x00, 0xff,  0xff, 0x33, 0xff, 0xff,  0xff, 0x33, 0xcc, 0xff,  0xff, 0x33, 0x99, 0xff,
    0xff, 0x33, 0x66, 0xff,  0xff, 0x33, 0x33, 0xff,  0xff, 0x33, 0x00, 0xff,  0xff, 0x00, 0xff, 0xff,
    0xff, 0x00, 0xcc, 0xff,  0xff, 0x00, 0x99, 0xff,  0xff, 0x00, 0x66, 0xff,  0xff, 0x00, 0x33, 0xff,
    0xff, 0x00, 0x00, 0xff,  0xcc, 0xff, 0xff, 0xff,  0xcc, 0xff, 0xcc, 0xff,  0xcc, 0xff, 0x99, 0xff,
    0xcc, 0xff, 0x66, 0xff,  0xcc, 0xff, 0x33, 0xff,  0xcc, 0xff, 0x00, 0xff,  0xcc, 0xcc, 0xff, 0xff,
    0xcc, 0xcc, 0xcc, 0xff,  0xcc, 0xcc, 0x99, 0xff,  0xcc, 0xcc, 0x66, 0xff,  0xcc, 0xcc, 0x33, 0xff,
    0xcc, 0xcc, 0x00, 0xff,  0xcc, 0x99, 0xff, 0xff,  0xcc, 0x99, 0xcc, 0xff,  0xcc, 0x99, 0x99, 0xff,
    0xcc, 0x99, 0x66, 0xff,  0xcc, 0x99, 0x33, 0xff,  0xcc, 0x99, 0x00, 0xff,  0xcc, 0x66, 0xff, 0xff,
    0xcc, 0x66, 0xcc, 0xff,  0xcc, 0x66, 0x99, 0xff,  0xcc, 0x66, 0x66, 0xff,  0xcc, 0x66, 0x33, 0xff,
    0xcc, 0x66, 0x00, 0xff,  0xcc, 0x33, 0xff, 0xff,  0xcc, 0x33, 0xcc, 0xff,  0xcc, 0x33, 0x99, 0xff,
    0xcc, 0x33, 0x66, 0xff,  0xcc, 0x33, 0x33, 0xff,  0xcc, 0x33, 0x00, 0xff,  0xcc, 0x00, 0xff, 0xff,
    0xcc, 0x00, 0xcc, 0xff,  0xcc, 0x00, 0x99, 0xff,  0xcc, 0x00, 0x66, 0xff,  0xcc, 0x00, 0x33, 0xff,
    0xcc, 0x00, 0x00, 0xff,  0x99, 0xff, 0xff, 0xff,  0x99, 0xff, 0xcc, 0xff,  0x99, 0xff, 0x99, 0xff,
    0x99, 0xff, 0x66, 0xff,  0x99, 0xff, 0x33, 0xff,  0x99, 0xff, 0x00, 0xff,  0x99, 0xcc, 0xff, 0xff,
    0x99, 0xcc, 0xcc, 0xff,  0x99, 0xcc, 0x99, 0xff,  0x99, 0xcc, 0x66, 0xff,  0x99, 0xcc, 0x33, 0xff,
    0x99, 0xcc, 0x00, 0xff,  0x99, 0x99, 0xff, 0xff,  0x99, 0x99, 0xcc, 0xff,  0x99, 0x99, 0x99, 0xff,
    0x99, 0x99, 0x66, 0xff,  0x99, 0x99, 0x33, 0xff,  0x99, 0x99, 0x00, 0xff,  0x99, 0x66, 0xff, 0xff,
    0x99, 0x66, 0xcc, 0xff,  0x99, 0x66, 0x99, 0xff,  0x99, 0x66, 0x66, 0xff,  0x99, 0x66, 0x33, 0xff,
    0x99, 0x66, 0x00, 0xff,  0x99, 0x33, 0xff, 0xff,  0x99, 0x33, 0xcc, 0xff,  0x99, 0x33, 0x99, 0xff,
    0x99, 0x33, 0x66, 0xff,  0x99, 0x33, 0x33, 0xff,  0x99, 0x33, 0x00, 0xff,  0x99, 0x00, 0xff, 0xff,
    0x99, 0x00, 0xcc, 0xff,  0x99, 0x00, 0x99, 0xff,  0x99, 0x00, 0x66, 0xff,  0x99, 0x00, 0x33, 0xff,
    0x99, 0x00, 0x00, 0xff,  0x66, 0xff, 0xff, 0xff,  0x66, 0xff, 0xcc, 0xff,  0x66, 0xff, 0x99, 0xff,
    0x66, 0xff, 0x66, 0xff,  0x66, 0xff, 0x33, 0xff,  0x66, 0xff, 0x00, 0xff,  0x66, 0xcc, 0xff, 0xff,
    0x66, 0xcc, 0xcc, 0xff,  0x66, 0xcc, 0x99, 0xff,  0x66, 0xcc, 0x66, 0xff,  0x66, 0xcc, 0x33, 0xff,
    0x66, 0xcc, 0x00, 0xff,  0x66, 0x99, 0xff, 0xff,  0x66, 0x99, 0xcc, 0xff,  0x66, 0x99, 0x99, 0xff,
    0x66, 0x99, 0x66, 0xff,  0x66, 0x99, 0x33, 0xff,  0x66, 0x99, 0x00, 0xff,  0x66, 0x66, 0xff, 0xff,
    0x66, 0x66, 0xcc, 0xff,  0x66, 0x66, 0x99, 0xff,  0x66, 0x66, 0x66, 0xff,  0x66, 0x66, 0x33, 0xff,
    0x66, 0x66, 0x00, 0xff,  0x66, 0x33, 0xff, 0xff,  0x66, 0x33, 0xcc, 0xff,  0x66, 0x33, 0x99, 0xff,
    0x66, 0x33, 0x66, 0xff,  0x66, 0x33, 0x33, 0xff,  0x66, 0x33, 0x00, 0xff,  0x66, 0x00, 0xff, 0xff,
    0x66, 0x00, 0xcc, 0xff,  0x66, 0x00, 0x99, 0xff,  0x66, 0x00, 0x66, 0xff,  0x66, 0x00, 0x33, 0xff,
    0x66, 0x00, 0x00, 0xff,  0x33, 0xff, 0xff, 0xff,  0x33, 0xff, 0xcc, 0xff,  0x33, 0xff, 0x99, 0xff,
    0x33, 0xff, 0x66, 0xff,  0x33, 0xff, 0x33, 0xff,  0x33, 0xff, 0x00, 0xff,  0x33, 0xcc, 0xff, 0xff,
    0x33, 0xcc, 0xcc, 0xff,  0x33, 0xcc, 0x99, 0xff,  0x33, 0xcc, 0x66, 0xff,  0x33, 0xcc, 0x33, 0xff,
    0x33, 0xcc, 0x00, 0xff,  0x33, 0x99, 0xff, 0xff,  0x33, 0x99, 0xcc, 0xff,  0x33, 0x99, 0x99, 0xff,
    0x33, 0x99, 0x66, 0xff,  0x33, 0x99, 0x33, 0xff,  0x33, 0x99, 0x00, 0xff,  0x33, 0x66, 0xff, 0xff,
    0x33, 0x66, 0xcc, 0xff,  0x33, 0x66, 0x99, 0xff,  0x33, 0x66, 0x66, 0xff,  0x33, 0x66, 0x33, 0xff,
    0x33, 0x66, 0x00, 0xff,  0x33, 0x33, 0xff, 0xff,  0x33, 0x33, 0xcc, 0xff,  0x33, 0x33, 0x99, 0xff,
    0x33, 0x33, 0x66, 0xff,  0x33, 0x33, 0x33, 0xff,  0x33, 0x33, 0x00, 0xff,  0x33, 0x00, 0xff, 0xff,
    0x33, 0x00, 0xcc, 0xff,  0x33, 0x00, 0x99, 0xff,  0x33, 0x00, 0x66, 0xff,  0x33, 0x00, 0x33, 0xff,
    0x33, 0x00, 0x00, 0xff,  0x00, 0xff, 0xff, 0xff,  0x00, 0xff, 0xcc, 0xff,  0x00, 0xff, 0x99, 0xff,
    0x00, 0xff, 0x66, 0xff,  0x00, 0xff, 0x33, 0xff,  0x00, 0xff, 0x00, 0xff,  0x00, 0xcc, 0xff, 0xff,
    0x00, 0xcc, 0xcc, 0xff,  0x00, 0xcc, 0x99, 0xff,  0x00, 0xcc, 0x66, 0xff,  0x00, 0xcc, 0x33, 0xff,
    0x00, 0xcc, 0x00, 0xff,  0x00, 0x99, 0xff, 0xff,  0x00, 0x99, 0xcc, 0xff,  0x00, 0x99, 0x99, 0xff,
    0x00, 0x99, 0x66, 0xff,  0x00, 0x99, 0x33, 0xff,  0x00, 0x99, 0x00, 0xff,  0x00, 0x66, 0xff, 0xff,
    0x00, 0x66, 0xcc, 0xff,  0x00, 0x66, 0x99, 0xff,  0x00, 0x66, 0x66, 0xff,  0x00, 0x66, 0x33, 0xff,
    0x00, 0x66, 0x00, 0xff,  0x00, 0x33, 0xff, 0xff,  0x00, 0x33, 0xcc, 0xff,  0x00, 0x33, 0x99, 0xff,
    0x00, 0x33, 0x66, 0xff,  0x00, 0x33, 0x33, 0xff,  0x00, 0x33, 0x00, 0xff,  0x00, 0x00, 0xff, 0xff,
    0x00, 0x00, 0xcc, 0xff,  0x00, 0x00, 0x99, 0xff,  0x00, 0x00, 0x66, 0xff,  0x00, 0x00, 0x33, 0xff,
    0xee, 0x00, 0x00, 0xff,  0xdd, 0x00, 0x00, 0xff,  0xbb, 0x00, 0x00, 0xff,  0xaa, 0x00, 0x00, 0xff,
    0x88, 0x00, 0x00, 0xff,  0x77, 0x00, 0x00, 0xff,  0x55, 0x00, 0x00, 0xff,  0x44, 0x00, 0x00, 0xff,
    0x22, 0x00, 0x00, 0xff,  0x11, 0x00, 0x00, 0xff,  0x00, 0xee, 0x00, 0xff,  0x00, 0xdd, 0x00, 0xff,
    0x00, 0xbb, 0x00, 0xff,  0x00, 0xaa, 0x00, 0xff,  0x00, 0x88, 0x00, 0xff,  0x00, 0x77, 0x00, 0xff,
    0x00, 0x55, 0x00, 0xff,  0x00, 0x44, 0x00, 0xff,  0x00, 0x22, 0x00, 0xff,  0x00, 0x11, 0x00, 0xff,
    0x00, 0x00, 0xee, 0xff,  0x00, 0x00, 0xdd, 0xff,  0x00, 0x00, 0xbb, 0xff,  0x00, 0x00, 0xaa, 0xff,
    0x00, 0x00, 0x88, 0xff,  0x00, 0x00, 0x77, 0xff,  0x00, 0x00, 0x55, 0xff,  0x00, 0x00, 0x44, 0xff,
    0x00, 0x00, 0x22, 0xff,  0x00, 0x00, 0x11, 0xff,  0xee, 0xee, 0xee, 0xff,  0xdd, 0xdd, 0xdd, 0xff,
    0xbb, 0xbb, 0xbb, 0xff,  0xaa, 0xaa, 0xaa, 0xff,  0x88, 0x88, 0x88, 0xff,  0x77, 0x77, 0x77, 0xff,
    0x55, 0x55, 0x55, 0xff,  0x44, 0x44, 0x44, 0xff,  0x22, 0x22, 0x22, 0xff,  0x11, 0x11, 0x11, 0xff
};

static guint32
id_to_uint (const gchar *id)
{
    if (strlen (id) != 4)
        return 0;
    return id[3] << 24 | id[2] << 16 | id[1] << 8 | id[0];
}

static gchar
id_char (guint8 value)
{
    gchar c = value;
    return isprint (c) ? c : '?';
}

static gchar *
uint_to_id (guint32 value)
{
    gchar id[5] = {
        id_char ((value >>  0) & 0xFF),
        id_char ((value >>  8) & 0xFF),
        id_char ((value >> 16) & 0xFF),
        id_char ((value >> 24) & 0xFF),
        '\0',
    };
    return g_strdup (id);
}

static guint32
read_uint (PvVoxFile *self,
           guint8    *data,
           gsize      data_length,
           gsize      offset)
{
    if (offset + 4 > data_length)
        return 0;

    return data[offset + 3] << 24 |
           data[offset + 2] << 16 |
           data[offset + 1] << 8 |
           data[offset + 0];
}

static gfloat
read_float (PvVoxFile *self,
            guint8    *data,
            gsize      data_length,
            gsize      offset)
{
    guint32 value = read_uint (self, data, data_length, offset);
    return *((gfloat *) &value);
}

static void
pv_vox_file_dispose (GObject *object)
{
    PvVoxFile *self = PV_VOX_FILE (object);

    g_clear_object (&self->file);
    g_clear_pointer (&self->data, g_free);
    g_clear_pointer (&self->models, g_ptr_array_unref);

    G_OBJECT_CLASS (pv_vox_file_parent_class)->dispose (object);
}

void
pv_vox_file_class_init (PvVoxFileClass *klass)
{
    GObjectClass *object_class = G_OBJECT_CLASS (klass);

    object_class->dispose = pv_vox_file_dispose;
}

void
pv_vox_file_init (PvVoxFile *self)
{
    self->models = g_ptr_array_new_with_free_func (g_free);
    for (int i = 0; i < 256; i++) {
        guint8 *color = default_palette + i * 4;
        self->materials[i].r = color[0];
        self->materials[i].g = color[1];
        self->materials[i].b = color[2];
        self->materials[i].a = color[3];
    }
}

PvVoxFile *
pv_vox_file_new (GFile *file)
{
    PvVoxFile *self;

    self = g_object_new (pv_vox_file_get_type (), NULL);

    self->file = g_object_ref (file);

    return self;
}

static gboolean
decode_chunks (PvVoxFile *self,
               guint8    *data,
               gsize      data_length,
               GError   **error)
{
    gsize offset = 0;
    while (offset < data_length) {
        gsize n_remaining = data_length - offset;

        /* Check enough space for header */
        guint8 *chunk_header = data + offset;
        gsize chunk_header_length = 12;
        if (n_remaining < chunk_header_length) {
            g_set_error_literal (error, G_IO_ERROR, G_IO_ERROR_FAILED, "Not enough space for chunk header");
            return FALSE;
        }

        /* Read header, check enough space for data */
        guint32 chunk_id = read_uint (self, chunk_header, n_remaining, 0);
        guint32 chunk_length = read_uint (self, chunk_header, n_remaining, 4);
        guint32 child_chunks_length = read_uint (self, chunk_header, n_remaining, 8);

        g_autofree gchar *id_string = uint_to_id (chunk_id);

        gsize n_required = chunk_header_length + chunk_length + child_chunks_length;
        if (n_required > n_remaining) {
            g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,
                         "Chunk %s requires %zi octets, but only %zi available", id_string, n_required, n_remaining);
            return FALSE;
        }

        guint8 *chunk_start = data + offset + chunk_header_length;
        guint8 *child_chunks_start = data + offset + chunk_header_length + chunk_length;

        if (chunk_id == id_to_uint ("MAIN")) {
        }
        else if (chunk_id == id_to_uint ("PACK")) {
            // FIXME: Check size >= 4
            //guint32 n_models = read_uint (self, chunk_start, chunk_length, 0);
        }
        else if (chunk_id == id_to_uint ("SIZE")) {
            // FIXME: Check size >= 12

            VoxModel *model = g_new0 (VoxModel, 1);
            model->size_x = read_uint (self, chunk_start, chunk_length, 0);
            model->size_y = read_uint (self, chunk_start, chunk_length, 4);
            model->size_z = read_uint (self, chunk_start, chunk_length, 8);
            g_ptr_array_add (self->models, model);
        }
        else if (chunk_id == id_to_uint ("XYZI")) {
            // FIXME: Check size >= 4

            guint32 voxels_length = read_uint (self, chunk_start, chunk_length, 0);
            if (4 + voxels_length * 4 > chunk_length) {
                guint32 max_voxels_length = (chunk_length / 4) - 4;
                g_warning ("XYZI block specified %u voxels but only space for %u", voxels_length, max_voxels_length);
                voxels_length = max_voxels_length;
            }

            VoxModel *model = self->models->len > 0 ? g_ptr_array_index (self->models, self->models->len - 1) : NULL;
            if (model == NULL) {
                g_warning ("Ignoring XYZI block without preceeding SIZE block");
            }
            else if (model->voxels != NULL) {
                g_warning ("Ignoring duplicate XYZI block");
            }
            else {
                model->voxels = chunk_start + 4;
                model->voxels_length = voxels_length;
            }
        }
        else if (chunk_id == id_to_uint ("RGBA")) {
            g_printerr ("RGBA %u\n", chunk_length);
            for (int offset = 0, index = 1; offset < chunk_length && index < 256; offset += 4, index++) {
                self->materials[index].r = chunk_start[offset + 0];
                self->materials[index].g = chunk_start[offset + 1];
                self->materials[index].b = chunk_start[offset + 2];
                self->materials[index].a = chunk_start[offset + 3];
            }
        }
        else if (chunk_id == id_to_uint ("MATT")) {
            // FIXME: Check size >= 16
            guint32 id = read_uint (self, chunk_start, chunk_length, 0);
            // FIXME: Check id between 1 and 255
            PvVoxMaterial null_material;
            PvVoxMaterial *material = id < 256 ? &self->materials[id] : &null_material;
            material->type = read_uint (self, chunk_start, chunk_length, 4);
            material->weight = read_float (self, chunk_start, chunk_length, 8);
            guint32 property_bits = read_uint (self, chunk_start, chunk_length, 12);
            gsize property_offset = 0;
            if (property_bits & 0x00000001) {
                material->plastic = read_float (self, chunk_start, chunk_length, property_offset);
                property_offset += 4;
            }
            if (property_bits & 0x00000002) {
                material->roughness = read_float (self, chunk_start, chunk_length, property_offset);
                property_offset += 4;
            }
            if (property_bits & 0x00000004) {
                material->specular = read_float (self, chunk_start, chunk_length, property_offset);
                property_offset += 4;
            }
            if (property_bits & 0x00000008) {
                material->ior = read_float (self, chunk_start, chunk_length, property_offset);
                property_offset += 4;
            }
            if (property_bits & 0x00000010) {
                material->attenuation = read_float (self, chunk_start, chunk_length, property_offset);
                property_offset += 4;
            }
            if (property_bits & 0x00000020) {
                material->power = read_float (self, chunk_start, chunk_length, property_offset);
                property_offset += 4;
            }
            if (property_bits & 0x00000040) {
                material->glow = read_float (self, chunk_start, chunk_length, property_offset);
                property_offset += 4;
            }
            if (property_bits & 0x00000080) {
                material->is_total_power = TRUE;
            }
        }
        else
            g_debug ("Ignoring unknown MagicaVoxel chunk %s", id_string);

        /* Decode child chunks */
        if (child_chunks_length > 0)
            if (!decode_chunks (self, child_chunks_start, child_chunks_length, error))
                return FALSE;

        offset += chunk_header_length + chunk_length + child_chunks_length;
    }

    return TRUE;
}

gboolean
pv_vox_file_decode (PvVoxFile    *self,
                    GCancellable *cancellable,
                    GError      **error)
{
    g_return_val_if_fail (PV_IS_VOX_FILE (self), FALSE);

    if (!g_file_load_contents (self->file, cancellable, (gchar **)&self->data, &self->data_length, NULL, error))
        return FALSE;

    if (self->data_length < 8) {
        g_set_error_literal (error, G_IO_ERROR, G_IO_ERROR_FAILED, "Not a MagicaVoxel file");
        return FALSE;
    }

    guint32 id = read_uint (self, self->data, self->data_length, 0);
    if (id != id_to_uint ("VOX ")) {
        g_set_error_literal (error, G_IO_ERROR, G_IO_ERROR_FAILED, "Not a MagicaVoxel file");
        return FALSE;
    }
    guint32 version = read_uint (self, self->data, self->data_length, 4);
    g_printerr ("version: %u\n", version);

    return decode_chunks (self, self->data + 8, self->data_length - 8, error);
}

void
pv_vox_file_get_size (PvVoxFile *self,
                      guint32   *size_x,
                      guint32   *size_y,
                      guint32   *size_z)
{
    g_return_if_fail (PV_IS_VOX_FILE (self));
    g_return_if_fail (self->models->len > 0);

    VoxModel *model = g_ptr_array_index (self->models, 0);

    if (size_x != NULL)
        *size_x = model->size_x;
    if (size_y != NULL)
        *size_y = model->size_y;
    if (size_z != NULL)
        *size_z = model->size_z;
}

guint32
pv_vox_file_get_voxel_count (PvVoxFile *self)
{
    g_return_val_if_fail (PV_IS_VOX_FILE (self), 0);
    g_return_val_if_fail (self->models->len > 0, 0);

    VoxModel *model = g_ptr_array_index (self->models, 0);
    return model->voxels_length;
}

void
pv_vox_file_get_voxel (PvVoxFile *self,
                       guint32    index,
                       guint8    *x,
                       guint8    *y,
                       guint8    *z,
                       guint8    *color_index)
{
    g_return_if_fail (PV_IS_VOX_FILE (self));
    g_return_if_fail (self->models->len > 0);

    VoxModel *model = g_ptr_array_index (self->models, 0);
    if (index >= model->voxels_length)
        return;

    guint8 *voxel = model->voxels + index * 4;
    if (x != NULL)
        *x = voxel[0];
    if (y != NULL)
        *y = voxel[1];
    if (z != NULL)
        *z = voxel[2];
    if (color_index != NULL)
        *color_index = voxel[3];
}

PvVoxMaterial *
pv_vox_file_get_material (PvVoxFile *self,
                          guint8     index)
{
    g_return_val_if_fail (PV_IS_VOX_FILE (self), NULL);
    return &self->materials[index];
}
